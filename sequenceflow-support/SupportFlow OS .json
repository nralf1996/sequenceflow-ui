{
  "name": "SupportFlow OS",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "filters": {
          "labelIds": [
            "INBOX",
            "UNREAD"
          ]
        }
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [
        -1328,
        224
      ],
      "id": "c2a3cd0d-fe7b-4806-876b-338bfad3470f",
      "name": "Gmail Trigger",
      "credentials": {
        "gmailOAuth2": {
          "id": "11Z6SCGwDdWRnHOf",
          "name": "Sequence Flow Gmail"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const raw = $json;\n\nlet from = \"\";\n\n// Case 1: Gmail Trigger nested structure\nif (raw.from && typeof raw.from === \"object\" && raw.from.email) {\n  from = raw.from.email;\n}\n\n// Case 2: simple lowercase string\nelse if (typeof raw.from === \"string\") {\n  from = raw.from;\n}\n\n// Case 3: capitalized header\nelse if (typeof raw.From === \"string\") {\n  const match = raw.From.match(/<(.+?)>/);\n  from = match ? match[1] : raw.From;\n}\n\nconst subject = raw.subject || raw.Subject || \"\";\nconst snippet = raw.snippet || \"\";\nconst text = raw.text || snippet || \"\";\n\nconst listId =\n  raw.headers?.[\"list-id\"] ||\n  raw.headers?.[\"List-Id\"] ||\n  raw[\"List-Id\"] ||\n  raw[\"list-id\"] ||\n  \"\";\n\nreturn [{\n  json: {\n    ...raw,\n    subject,\n    from,\n    snippet,\n    text,\n    listId\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1104,
        224
      ],
      "id": "5cae99d0-1015-4bd9-ae09-5fdab71e7e87",
      "name": "Parse Email"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cond-noreply",
              "leftValue": "={{ $json.from }}",
              "rightValue": "no-reply",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            },
            {
              "id": "cond-noreply2",
              "leftValue": "={{ $json.from }}",
              "rightValue": "noreply",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            },
            {
              "id": "cond-google",
              "leftValue": "={{ $json.from }}",
              "rightValue": "@google.com",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            },
            {
              "id": "cond-security",
              "leftValue": "={{ $json.subject }}",
              "rightValue": "Security alert",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            },
            {
              "id": "cond-listid",
              "leftValue": "={{ $json.listId }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1344,
        -208
      ],
      "id": "239a6310-d700-496c-9afa-250ab1c22eff",
      "name": "Support Gate",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const input = $json;\n\nreturn [{\n  json: {\n    from: input.from || \"\",\n    subject: input.subject || \"\",\n    text: input.text || input.snippet || \"\",\n    snippet: input.snippet || \"\",\n    customerName: \"klant\",\n    listId: input.listId || \"\",\n    threadId: input.threadId || input.id || \"\"   // ðŸ”¥ BELANGRIJK\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        224
      ],
      "id": "f82bf6fa-748b-494a-89d4-60c4e276d54d",
      "name": "Normalize Input"
    },
    {
      "parameters": {
        "jsCode": "const text = ($json.subject + \" \" + $json.text).toLowerCase();\n\nlet intent = \"unknown\";\n\nif (/beschadigd|kapot|defect|stuk|krassen|scheur|damaged|broken/.test(text)) {\n  intent = \"damaged\";\n} else if (/retour|terugsturen|refund|terugbetaling|return/.test(text)) {\n  intent = \"return\";\n} else if (/ontbreekt|missen|niet compleet|mist|ontbrekend|missing/.test(text)) {\n  intent = \"missing_items\";\n} else if (/waar blijft|niet ontvangen|nog niet|te laat|vertraging|late|delay/.test(text)) {\n  intent = \"late_delivery\";\n}\n\nreturn [{\n  json: {\n    ...$json,\n    intent\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        224
      ],
      "id": "1732913d-4851-4355-8f5d-6d5018bf160a",
      "name": "Intent Classifier"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "cond-intent-unknown",
              "leftValue": "={{ $json.intent }}",
              "rightValue": "unknown",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -16,
        224
      ],
      "id": "2f83704b-92c4-4ee0-94ba-51ca36cac03d",
      "name": "Router"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "assign-draft-subject",
              "name": "draft.subject",
              "value": "={{ 'Re: ' + $json.subject }}",
              "type": "string"
            },
            {
              "id": "assign-draft-body",
              "name": "draft.body",
              "value": "={{ \n($json.intent === 'damaged' \n? 'Beste ' + ($json.customerName || 'klant') + ',\\n\\nWat vervelend om te horen dat uw bestelling beschadigd is aangekomen.\\n\\nKunt u ons het ordernummer en 1-2 foto\\'s van de schade sturen? Dan lossen wij dit direct voor u op.' \n\n: $json.intent === 'late_delivery' \n? 'Beste ' + ($json.customerName || 'klant') + ',\\n\\nWat vervelend dat uw bestelling nog niet is aangekomen.\\n\\nKunt u ons uw ordernummer sturen? Dan kijken wij direct de status na en koppelen dit aan u terug.' \n\n: $json.intent === 'return' \n? 'Beste ' + ($json.customerName || 'klant') + ',\\n\\nU kunt uw bestelling retourneren via onze retourprocedure.\\n\\nStuur ons uw ordernummer, dan sturen wij u direct de retourinstructies.' \n\n: $json.intent === 'missing_items' \n? 'Beste ' + ($json.customerName || 'klant') + ',\\n\\nDank voor uw bericht. Het spijt ons dat er iets ontbreekt in uw levering.\\n\\nKunt u ons uw ordernummer en welke onderdelen ontbreken sturen? Dan lossen wij dit direct op.' \n\n: 'Beste ' + ($json.customerName || 'klant') + ',\\n\\nDank voor uw bericht. Kunt u ons uw ordernummer doorgeven? Dan helpen wij u direct verder.' \n\n) \n+ '\\n\\nMet vriendelijke groet,\\n\\nTeam SequenceFlow'\n}}",
              "type": "string"
            },
            {
              "id": "04cdd6dc-0b7e-4669-ac15-a632c145dd8d",
              "name": "from",
              "value": "={{ $json.from }}",
              "type": "string"
            },
            {
              "id": "34598751-fd8d-4c5c-9a57-3ae23e9a7e9f",
              "name": "threadId",
              "value": "={{ $json.threadId }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        208,
        432
      ],
      "id": "3888f80c-4f8f-4a2c-a545-b6b8f98de3f6",
      "name": "Template"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://emailreply.sequenceflow.io/api/support/generate",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {}
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.text }}"
            },
            {
              "name": "subject",
              "value": "={{ $json.subject }}"
            },
            {
              "name": "from",
              "value": "={{ $json.from }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        192,
        32
      ],
      "id": "57e789c0-30ea-46af-b964-0963fa90f305",
      "name": "AI"
    },
    {
      "parameters": {
        "jsCode": "const input = $json;\n\nlet subject = \"\";\nlet body = \"\";\nlet from = input.draft?.from || input.from || \"\";\n\nif (input.draft && input.draft.subject && input.draft.body) {\n  subject = input.draft.subject;\n  body = input.draft.body;\n} else {\n  const name = input.customerName || \"klant\";\n  subject = \"Re: \" + (input.subject || \"\");\n  body =\n    \"Beste \" +\n    name +\n    \",\\n\\nDank voor uw bericht. Kunt u ons uw ordernummer doorgeven?\\n\\nMet vriendelijke groet,\";\n}\n\nreturn [\n  {\n    json: {\n      ...$json,\n      draft: {\n        subject,\n        body,\n        from,\n      },\n    },\n  },\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        432,
        224
      ],
      "id": "095213dc-c4ae-474a-8ad4-c40cdb958e2f",
      "name": "Normalize Output"
    },
    {
      "parameters": {
        "resource": "draft",
        "subject": "={{$json.draft.subject}}",
        "message": "={{$json.draft.body}}",
        "options": {
          "sendTo": "={{$json.draft.from}}"
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        656,
        224
      ],
      "id": "b3b5b6f5-a209-4a5b-84fe-78b98d748d49",
      "name": "Create Draft",
      "webhookId": "a53f0468-c292-4cd9-bd06-874944db348f",
      "credentials": {
        "gmailOAuth2": {
          "id": "11Z6SCGwDdWRnHOf",
          "name": "Sequence Flow Gmail"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * Support Email Gatekeeper (n8n Code node)\n *\n * Place this right after \"Parse Email\".\n * Returns:\n *  - allowed: true  -> continue workflow\n *  - allowed: false -> stop / route to ignored branch\n */\n\nconst input = $json;\n\n// ---------------------------\n// Helpers\n// ---------------------------\nfunction toStr(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try {\n    return String(v);\n  } catch {\n    return \"\";\n  }\n}\n\nfunction norm(s) {\n  return toStr(s).toLowerCase().trim();\n}\n\n// Extract email address from \"Name <email@x.com>\" or raw string\nfunction extractEmail(raw) {\n  const s = toStr(raw).trim();\n  if (!s) return \"\";\n  const m = s.match(/<([^>]+)>/);\n  if (m && m[1]) return m[1].trim().toLowerCase();\n  return s.toLowerCase();\n}\n\nfunction includesAny(haystack, needles) {\n  const h = norm(haystack);\n  return needles.some((n) => h.includes(n));\n}\n\nfunction matchesAnyRegex(text, regexList) {\n  const t = toStr(text);\n  return regexList.some((r) => r.test(t));\n}\n\nfunction firstNonEmpty(...vals) {\n  for (const v of vals) {\n    const s = toStr(v).trim();\n    if (s) return s;\n  }\n  return \"\";\n}\n\n// ---------------------------\n// Gather fields from Parse Email output\n// (Parse Email sometimes outputs both \"From\" and \"from\", etc.)\n// ---------------------------\nconst subjectRaw = firstNonEmpty(input.subject, input.Subject);\nconst snippetRaw = firstNonEmpty(input.snippet, input.Snippet);\nconst textRaw = firstNonEmpty(input.text, input.Text, input.body, input.Body);\n\n// From: try multiple common keys\nconst fromRaw = firstNonEmpty(input.from, input.From, input.sender, input.email);\nconst fromEmail = extractEmail(fromRaw);\n\n// To / delivered-to / listId can help\nconst toRaw = firstNonEmpty(input.to, input.To, input.deliveredTo, input[\"Delivered-To\"]);\nconst listIdRaw = firstNonEmpty(input.listId, input[\"List-Id\"], input[\"list-id\"], input[\"List-id\"]);\n\n// If your parser returns headers object, also consider it\nconst headers = input.headers || input.payload?.headers || null;\n\n// Pull some header-like strings for matching (optional)\nconst headerBlob = headers ? JSON.stringify(headers) : \"\";\n\n// Make one big text to classify\nconst subject = toStr(subjectRaw).trim();\nconst snippet = toStr(snippetRaw).trim();\nconst text = toStr(textRaw).trim();\nconst fullText = `${subject}\\n\\n${snippet}\\n\\n${text}\\n\\n${toStr(toRaw)}\\n\\n${toStr(listIdRaw)}\\n\\n${headerBlob}`.toLowerCase();\n\n// ---------------------------\n// Hard block rules (senders / patterns)\n// ---------------------------\n\n// Senders/domains that are almost never \"customer support requests\"\nconst BLOCK_FROM_CONTAINS = [\n  \"no-reply\",\n  \"noreply\",\n  \"donotreply\",\n  \"do-not-reply\",\n  \"mailer-daemon\",\n  \"postmaster\",\n  \"bounce\",\n  \"notifications@\",\n  \"notification@\",\n  \"news@\",\n  \"newsletter@\",\n  \"support@webshare.io\",              // jouw voorbeeld\n  \"followsuggestions@mail.instagram.com\", // jouw voorbeeld\n  \"mail.instagram.com\",\n  \"facebookmail.com\",\n  \"accounts.google.com\",\n];\n\n// Domain-level blocks (receipts, social, automated)\nconst BLOCK_FROM_DOMAIN_ENDS = [\n  \"@mail.instagram.com\",\n  \"@facebookmail.com\",\n  \"@accounts.google.com\",\n  \"@noreply.google.com\",\n  \"@google.com\", // let op: dit blokt ook echte google users; daarom alleen gebruiken als jij dit echt wil\n];\n\n// Subject keywords that are almost always automated/irrelevant\nconst BLOCK_SUBJECT_CONTAINS = [\n  \"receipt\",\n  \"invoice\",\n  \"payment\",\n  \"paid\",\n  \"order confirmation\",\n  \"bevestiging\",\n  \"bevestigingsmail\",\n  \"factuur\",\n  \"betaal\",\n  \"betaling\",\n  \"abonnee\",\n  \"subscription\",\n  \"trial\",\n  \"your webshare software receipt\", // jouw voorbeeld\n  \"security alert\",\n  \"login alert\",\n  \"new login\",\n  \"verification\",\n  \"verify your email\",\n  \"confirm your email\",\n  \"password reset\",\n  \"reset your password\",\n  \"two-factor\",\n  \"2fa\",\n  \"otp\",\n  \"code:\",\n  \"welcome to\",\n  \"thanks for signing up\",\n];\n\n// Newsletter / marketing indicators\nconst BLOCK_MARKETING_CONTAINS = [\n  \"unsubscribe\",\n  \"afmelden\",\n  \"view in browser\",\n  \"bekijk in browser\",\n  \"marketing\",\n  \"promotion\",\n  \"promotie\",\n  \"advertisement\",\n];\n\n// Regex patterns that scream â€œautomatedâ€\nconst BLOCK_REGEX = [\n  /unsubscribe/i,\n  /afmelden/i,\n  /do-?not-?reply/i,\n  /no-?reply/i,\n  /mailer-daemon/i,\n  /password\\s*reset/i,\n  /verify\\s*your\\s*email/i,\n  /\\bsecurity\\s*alert\\b/i,\n  /\\blogin\\s*alert\\b/i,\n];\n\n// ---------------------------\n// Positive \"support intent\" rules\n// If none match, we can still allow, but we prefer to block obvious non-support.\n// ---------------------------\nconst SUPPORT_KEYWORDS = [\n  \"bestelling\",\n  \"order\",\n  \"ordernummer\",\n  \"pakket\",\n  \"levering\",\n  \"bezorg\",\n  \"track\",\n  \"trace\",\n  \"t&t\",\n  \"retour\",\n  \"refund\",\n  \"terug\",\n  \"kapot\",\n  \"beschadigd\",\n  \"defect\",\n  \"ontbreekt\",\n  \"missen\",\n  \"garantie\",\n  \"klacht\",\n  \"probleem\",\n  \"vraag\",\n  \"help\",\n];\n\n// Detect if this looks like human-written (rough heuristic)\nfunction looksHuman(text) {\n  const t = norm(text);\n  if (!t) return false;\n\n  // If it contains typical email sign-offs or natural phrasing\n  const humanMarkers = [\"groetjes\", \"met vriendelijke groet\", \"alvast bedankt\", \"hoi\", \"hallo\", \"beste\", \"kunt u\", \"kunnen jullie\"];\n  if (humanMarkers.some((m) => t.includes(m))) return true;\n\n  // If it contains question marks\n  if (t.includes(\"?\")) return true;\n\n  return false;\n}\n\n// ---------------------------\n// Decision engine\n// ---------------------------\n\nlet allowed = true;\nlet reason = \"OK\";\n\n// 1) Hard block: list emails (newsletter)\nif (toStr(listIdRaw).trim()) {\n  allowed = false;\n  reason = \"Has List-Id header (newsletter/list mail)\";\n}\n\n// 2) Hard block: from contains blocked patterns\nif (allowed && includesAny(fromEmail, BLOCK_FROM_CONTAINS)) {\n  allowed = false;\n  reason = `Blocked sender pattern: ${fromEmail}`;\n}\n\n// 3) Hard block: from domain ends\nif (allowed && BLOCK_FROM_DOMAIN_ENDS.some((d) => fromEmail.endsWith(d))) {\n  allowed = false;\n  reason = `Blocked sender domain: ${fromEmail}`;\n}\n\n// 4) Hard block: subject contains automated keywords\nif (allowed && includesAny(subject, BLOCK_SUBJECT_CONTAINS)) {\n  allowed = false;\n  reason = `Blocked subject keyword: \"${subject}\"`;\n}\n\n// 5) Hard block: marketing content markers\nif (allowed && includesAny(fullText, BLOCK_MARKETING_CONTAINS)) {\n  allowed = false;\n  reason = \"Looks like newsletter/marketing (unsubscribe markers)\";\n}\n\n// 6) Hard block: regex automated\nif (allowed && matchesAnyRegex(fullText, BLOCK_REGEX)) {\n  allowed = false;\n  reason = \"Matches automated email regex rule\";\n}\n\n// 7) Soft allow: if it clearly looks like support\nconst supportHit = SUPPORT_KEYWORDS.some((k) => fullText.includes(k));\nconst humanHit = looksHuman(fullText);\n\n// 8) If it doesn't look like support AND doesn't look human, block it\n// This prevents random system notifications slipping through even if they didn't match keywords above.\nif (allowed && !supportHit && !humanHit) {\n  allowed = false;\n  reason = \"No support keywords and does not look like human-written support email\";\n}\n\n// ---------------------------\n// Return normalized payload\n// We keep original fields, but add allowed + reason + normalized fields.\n// ---------------------------\nreturn {\n  json: {\n    ...input,\n    normalized: {\n      subject,\n      snippet,\n      text,\n      fromEmail,\n      to: toStr(toRaw).trim(),\n      listId: toStr(listIdRaw).trim(),\n    },\n    allowed,\n    blockedReason: allowed ? null : reason,\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -896,
        224
      ],
      "id": "1f0c2aa2-51b7-4b3a-811f-ac773662b71c",
      "name": "filterGate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "ffaecc36-ed3b-48b5-b932-a36daaef21aa",
              "leftValue": "={{$json.allowed}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -688,
        224
      ],
      "id": "431f52dc-ecf8-4485-80f2-046b10cb0e9e",
      "name": "If"
    }
  ],
  "pinData": {
    "Gmail Trigger": [
      {
        "json": {
          "From": "klant@gmail.com",
          "subject": "Combinatie van problemen",
          "text": "Mijn bestelling kwam laat aan en er ontbreekt ook nog een onderdeel. Daarnaast twijfel ik of ik het wil retourneren. Wat adviseren jullie?",
          "snippet": "Combinatie van problemen",
          "listId": ""
        }
      }
    ]
  },
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Parse Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Email": {
      "main": [
        [
          {
            "node": "filterGate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Support Gate": {
      "main": [
        [],
        []
      ]
    },
    "Normalize Input": {
      "main": [
        [
          {
            "node": "Intent Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intent Classifier": {
      "main": [
        [
          {
            "node": "Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router": {
      "main": [
        [
          {
            "node": "AI",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Template",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Template": {
      "main": [
        [
          {
            "node": "Normalize Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI": {
      "main": [
        [
          {
            "node": "Normalize Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Output": {
      "main": [
        [
          {
            "node": "Create Draft",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "filterGate": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "dfe766cc-0418-4da5-9d21-b149310ad63e",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "6b605a20b95a3ba2e77e646f9428910dc3bbf59aa432c06df596e7801f86f035"
  },
  "id": "6CYbpmdbGZdjl6Rp",
  "tags": []
}